<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive DNA Structure Model</title>
    <style>
        /* UPDATED: Background black, text white */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        
        /* UI Panels Common Style */
        .ui-panel {
            position: absolute;
            top: 20px;
            background: rgba(20, 20, 30, 0.9); /* Dark panel for contrast */
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            pointer-events: auto;
            user-select: none;
            color: white; 
        }

        /* Top Right: Only Pause/Resume */
        #ui-right {
            right: 20px;
            width: auto;
        }

        /* Top Left: Controls & Legend */
        #ui-left {
            left: 20px;
            width: 320px;
        }

        h2 { margin-top: 0; font-size: 18px; color: #00d2ff; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px; }

        /* Controls */
        .control-group { margin-bottom: 15px; display: flex; flex-direction: column; gap: 8px; }
        
        button {
            background: #00d2ff; color: #000; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; border-radius: 6px;
            transition: background 0.2s; font-size: 14px; white-space: nowrap;
        }
        button:hover { background: #66e0ff; }
        
        label { font-size: 12px; color: #aaa; display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; cursor: pointer; }

        /* Annotated Diagram / Legend */
        .legend { margin-top: 15px; border-top: 1px solid #444; paddingTop: 15px; }
        .legend h3 { font-size: 14px; margin: 0 0 10px 0; color: #fff; }
        
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; }
        .color-box { width: 16px; height: 16px; margin-right: 10px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.3); }
        
        .shape-circle { border-radius: 50%; }
        .shape-hex { 
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border: none;
        }

    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<!-- TOP LEFT PANEL: Settings & Legend -->
<div id="ui-left" class="ui-panel">
    <h2>DNA Settings</h2>

    <div class="control-group">
        <label for="speedRange"><span>Rotation Speed</span> <span id="speedVal">20%</span></label>
        <input type="range" id="speedRange" min="0" max="0.05" step="0.001" value="0.01">
    </div>

    <div class="control-group">
        <label for="twistRange"><span>Helix Twist Extent</span> <span id="twistVal">Normal</span></label>
        <input type="range" id="twistRange" min="0.1" max="1.0" step="0.05" value="0.5">
    </div>

    <div class="legend">
        <h3>Annotated Diagram & Key</h3>
        
        <div class="legend-item">
            <div class="color-box shape-circle" style="background: #ff0000;"></div>
            <span><strong>Phosphate Group</strong> (Outer sphere)</span>
        </div>
        
        <div class="legend-item">
            <div class="color-box" style="background: #0044ff;"></div>
            <span><strong>Carbon Sugar</strong> (Deoxyribose)</span>
        </div>
        
        <div class="legend-item">
            <div class="color-box" style="background: #00cc00; height: 4px; align-self: center;"></div>
            <span><strong>Phosphate-Sugar Bond</strong> (Backbone)</span>
        </div>

        <div class="legend-item">
            <div class="color-box shape-hex" style="background: #ffcc00; width: 14px; height: 16px;"></div>
            <span><strong>2-Ring Base</strong> (Larger Hex)</span>
        </div>

        <div class="legend-item">
            <div class="color-box shape-hex" style="background: #aa00ff; width: 14px; height: 16px;"></div>
            <span><strong>3-Ring Base</strong> (Larger Hex)</span>
        </div>

        <div class="legend-item">
             <div style="width: 16px; height: 16px; margin-right: 10px; display: flex; align-items: center; justify-content: center; gap: 2px;">
                <!-- Updated dots to white for black background -->
                <div style="width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
                <div style="width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
                <div style="width: 2px; height: 2px; background: #fff; border-radius: 50%;"></div>
            </div>
            <span><strong>Hydrogen Bond</strong> (Dotted Line)</span>
        </div>
        
        <p style="font-size: 11px; color: #888; margin-top: 10px; line-height: 1.4;">
            <strong>Interaction:</strong> Drag to rotate, Scroll to zoom.
        </p>
    </div>
</div>

<!-- TOP RIGHT PANEL: Pause Button -->
<div id="ui-right" class="ui-panel">
    <button id="toggleBtn">PAUSE ROTATION</button>
</div>

<script>
    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    // UPDATED: Black background
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 45); 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // 2. LIGHTING
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 0.9);
    pointLight.position.set(10, 10, 20);
    scene.add(pointLight);

    const backLight = new THREE.PointLight(0x00d2ff, 0.4);
    backLight.position.set(-10, -10, -20);
    scene.add(backLight);

    // 3. MATERIALS
    const matPhosphate = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100, emissive: 0x330000, emissiveIntensity: 0.2 }); 
    const matSugar = new THREE.MeshPhongMaterial({ color: 0x0044ff, shininess: 80, emissive: 0x001155, emissiveIntensity: 0.2 });    
    const matBond = new THREE.MeshBasicMaterial({ color: 0x00cc00 });                     
    const matBase2Ring = new THREE.MeshPhongMaterial({ color: 0xffcc00, shininess: 60 }); 
    const matBase3Ring = new THREE.MeshPhongMaterial({ color: 0xaa00ff, shininess: 60 }); 
    
    // UPDATED: White material for the "dots" of the hydrogen bond for visibility on black
    const matHDot = new THREE.MeshBasicMaterial({ color: 0xffffff }); 

    // 4. GEOMETRIES
    const geoPhosphate = new THREE.SphereGeometry(0.6, 16, 16);
    const geoSugar = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 5);
    const geoRing = new THREE.TorusGeometry(0.55, 0.15, 8, 6); 
    const geoBond = new THREE.CylinderGeometry(0.1, 0.1, 1);
    
    // Geometry for a single dash in the hydrogen bond
    const geoDash = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8); 

    // 5. DNA CONTAINER
    const dnaGroup = new THREE.Group();
    // UPDATED: Shifted to the right (x=10) so the left box doesn't cover it
    dnaGroup.position.x = 10; 
    scene.add(dnaGroup);

    // Params
    const numPairs = 30;
    const radius = 6;
    const heightPerPair = 1.2;
    let twistPerPair = 0.5; // Controlled by slider
    
    // Constants used for gap calculation
    const baseSeparation = 1.2;
    const baseStartOffset = 0.8;

    // Helper to create a multi-ring base
    function createBase(numRings, material) {
        const baseGroup = new THREE.Group();
        
        for(let r=0; r<numRings; r++) {
            const ringMesh = new THREE.Mesh(geoRing, material);
            // Rotate Z by PI/6 (30 deg) to orient the hexagon flat side
            ringMesh.rotation.set(Math.PI / 2, 0, Math.PI / 6); 
            
            // Stack them along Z
            ringMesh.position.z = r * baseSeparation;
            baseGroup.add(ringMesh);
        }
        
        const wrapper = new THREE.Group();
        // Shift meshes so Z=0 is the attachment point to the sugar
        baseGroup.position.z = baseStartOffset; 
        wrapper.add(baseGroup);
        return wrapper;
    }

    // FUNCTION TO BUILD DNA (called initially and on slider change)
    function buildDNA() {
        while(dnaGroup.children.length > 0){ 
            dnaGroup.remove(dnaGroup.children[0]); 
        }

        for (let i = 0; i < numPairs; i++) {
            const y = (i * heightPerPair) - (numPairs * heightPerPair / 2);
            const angle = i * twistPerPair;

            // --- STRAND 1 COORDINATES ---
            const x1 = Math.cos(angle) * radius;
            const z1 = Math.sin(angle) * radius;

            // --- STRAND 2 COORDINATES (Opposite side) ---
            const x2 = Math.cos(angle + Math.PI) * radius;
            const z2 = Math.sin(angle + Math.PI) * radius;

            const isStrand1TwoRing = i % 2 === 0;

            // === STRAND 1 ===
            const sugar1 = new THREE.Mesh(geoSugar, matSugar);
            sugar1.position.set(x1, y, z1);
            sugar1.rotation.y = angle;
            sugar1.rotation.x = Math.PI / 2;
            dnaGroup.add(sugar1);

            const p1x = Math.cos(angle + 0.5) * (radius + 1.5);
            const p1z = Math.sin(angle + 0.5) * (radius + 1.5);
            const phos1 = new THREE.Mesh(geoPhosphate, matPhosphate);
            phos1.position.set(p1x, y + (heightPerPair/2), p1z);
            dnaGroup.add(phos1);

            const bond1 = new THREE.Mesh(geoBond, matBond);
            const dist1 = sugar1.position.distanceTo(phos1.position);
            bond1.scale.y = dist1; 
            bond1.position.copy(sugar1.position).lerp(phos1.position, 0.5);
            bond1.lookAt(phos1.position);
            bond1.rotateX(Math.PI / 2); 
            dnaGroup.add(bond1);

            const base1 = createBase(isStrand1TwoRing ? 2 : 3, isStrand1TwoRing ? matBase2Ring : matBase3Ring);
            base1.position.set(x1, y, z1);
            base1.lookAt(0, y, 0); 
            dnaGroup.add(base1);

            // === STRAND 2 ===
            const sugar2 = new THREE.Mesh(geoSugar, matSugar);
            sugar2.position.set(x2, y, z2);
            sugar2.rotation.y = angle + Math.PI;
            sugar2.rotation.x = Math.PI / 2;
            dnaGroup.add(sugar2);

            const p2x = Math.cos(angle + Math.PI + 0.5) * (radius + 1.5);
            const p2z = Math.sin(angle + Math.PI + 0.5) * (radius + 1.5);
            const phos2 = new THREE.Mesh(geoPhosphate, matPhosphate);
            phos2.position.set(p2x, y + (heightPerPair/2), p2z);
            dnaGroup.add(phos2);

            const bond2 = new THREE.Mesh(geoBond, matBond);
            const dist2 = sugar2.position.distanceTo(phos2.position);
            bond2.scale.y = dist2;
            bond2.position.copy(sugar2.position).lerp(phos2.position, 0.5);
            bond2.lookAt(phos2.position);
            bond2.rotateX(Math.PI / 2);
            dnaGroup.add(bond2);

            const base2 = createBase(isStrand1TwoRing ? 3 : 2, isStrand1TwoRing ? matBase3Ring : matBase2Ring);
            base2.position.set(x2, y, z2);
            base2.lookAt(0, y, 0);
            dnaGroup.add(base2);

            // === UPDATED CENTRAL H-BOND (GAP FILLING) ===
            // Calculate where the bases end to fill the gap exactly
            
            // Length of base 1 (distance from x1,z1 towards center)
            const rings1 = isStrand1TwoRing ? 2 : 3;
            // The last ring is at: offset + (rings-1)*separation
            // But we want visual edge, so let's add ~0.5 for ring radius
            const len1 = baseStartOffset + (rings1 - 1) * baseSeparation; 
            
            // Length of base 2
            const rings2 = isStrand1TwoRing ? 3 : 2;
            const len2 = baseStartOffset + (rings2 - 1) * baseSeparation;
            
            // Radius is 6.
            // Inner edge of Base 1 is at (Radius - len1)
            // Inner edge of Base 2 is at (Radius - len2) on the other side
            // Total Gap = (Radius - len1) + (Radius - len2)
            const innerEdge1 = radius - len1;
            const innerEdge2 = radius - len2;
            const totalGap = innerEdge1 + innerEdge2;
            
            // Offset calculation:
            // If len1 is smaller (short base), innerEdge1 is larger (gap starts further out)
            // We need to shift the bond towards the shorter base.
            // Shift = (innerEdge1 - innerEdge2) / 2
            const gapOffset = (innerEdge1 - innerEdge2) / 2;
            
            // Create bond group
            const hBondGroup = new THREE.Group();
            
            // Add a small overlap (0.8) so lines definitely touch/enter the hex rings
            const bondLength = totalGap + 0.8; 
            const numDashes = 7;
            const spacing = bondLength / numDashes;
            
            for(let d=0; d<numDashes; d++) {
                const dash = new THREE.Mesh(geoDash, matHDot);
                
                // Position centered around 0 locally
                const xPos = - (bondLength/2) + (d * spacing) + (spacing/2);
                
                // Apply the calculated offset to shift bond into the gap center
                dash.position.set(xPos + gapOffset, 0, 0);
                dash.rotation.z = Math.PI / 2;
                
                hBondGroup.add(dash);
            }
            
            // Rotate the entire group to match the helix angle
            hBondGroup.rotation.y = angle;
            hBondGroup.position.set(0, y, 0);
            
            dnaGroup.add(hBondGroup);
        }
    }

    // Initial Build
    buildDNA();

    // 6. ANIMATION & EVENTS
    let isPlaying = true;
    let speed = 0.01;

    const toggleBtn = document.getElementById('toggleBtn');
    const speedRange = document.getElementById('speedRange');
    const speedVal = document.getElementById('speedVal');
    const twistRange = document.getElementById('twistRange');
    const twistVal = document.getElementById('twistVal');

    toggleBtn.addEventListener('click', () => {
        isPlaying = !isPlaying;
        toggleBtn.textContent = isPlaying ? "PAUSE ROTATION" : "RESUME ROTATION";
        toggleBtn.style.background = isPlaying ? "#00d2ff" : "#ff4444";
        toggleBtn.style.color = isPlaying ? "#000" : "#fff";
    });

    speedRange.addEventListener('input', (e) => {
        speed = parseFloat(e.target.value);
        speedVal.textContent = Math.round((speed / 0.05) * 100) + "%";
    });

    twistRange.addEventListener('input', (e) => {
        twistPerPair = parseFloat(e.target.value);
        twistVal.textContent = twistPerPair.toFixed(2);
        buildDNA(); // Rebuild structure on change
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            dnaGroup.rotation.y -= speed;
        }

        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
