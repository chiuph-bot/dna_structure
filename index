<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive DNA Structure Model</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; color: white; }
        #ui-container {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); padding: 20px;
            border-radius: 8px; border: 1px solid #444;
        }
        button {
            background: #00d2ff; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; border-radius: 4px;
        }
        button:hover { background: #00aaff; }
        label { display: block; margin-top: 15px; }
        .legend { margin-top: 20px; font-size: 14px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .dot { width: 12px; height: 12px; margin-right: 10px; border-radius: 50%; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="ui-container">
    <h2>DNA Structure Control</h2>
    <button id="toggleBtn">PAUSE</button>
    
    <label for="speedRange">Rotation Speed</label>
    <input type="range" id="speedRange" min="0" max="0.1" step="0.001" value="0.02">

    <div class="legend">
        <h3>Legend</h3>
        <div class="legend-item"><div class="dot" style="background:red;"></div>Phosphate Group</div>
        <div class="legend-item"><div class="dot" style="background:#0066ff;"></div>Carbon Sugar (Deoxyribose)</div>
        <div class="legend-item"><div class="dot" style="background:#00ff00;"></div>Phosphate-Sugar Bond (Green)</div>
        <div class="legend-item"><div class="dot" style="background:gold;"></div>Base (2 Rings - Purine)</div>
        <div class="legend-item"><div class="dot" style="background:purple;"></div>Base (1 Ring - Pyrimidine)</div>
    </div>
</div>

<script>
    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111); // Dark background
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25;
    camera.position.y = 0;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(10, 10, 20);
    scene.add(light);
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
    scene.add(ambientLight);

    // --- DNA GROUP ---
    const dnaGroup = new THREE.Group();
    scene.add(dnaGroup);

    // --- MATERIALS ---
    const phosphateMat = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red
    const sugarMat = new THREE.MeshLambertMaterial({ color: 0x0066ff });     // Blue
    const bondMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });      // Green (Requested)
    const basePurineMat = new THREE.MeshLambertMaterial({ color: 0xffd700 }); // Gold (2 rings)
    const basePyrimMat = new THREE.MeshLambertMaterial({ color: 0x800080 });  // Purple (1 ring)
    const connectorMat = new THREE.MeshBasicMaterial({ color: 0xffffff });   // H-bonds (White)

    // --- GEOMETRIES ---
    const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16);
    const sugarGeo = new THREE.DodecahedronGeometry(0.7); // Slightly different shape for sugar
    
    // --- BUILD HELIX ---
    const height = 30;
    const steps = 20; // Number of base pairs
    const radius = 6;
    const twistPerStep = 0.5; // Radians

    for (let i = 0; i < steps; i++) {
        const y = (i * 2) - (height / 2); // Vertical position
        const angle = i * twistPerStep;

        // Calculate positions for Strand A
        const x1 = Math.cos(angle) * radius;
        const z1 = Math.sin(angle) * radius;
        
        // Calculate positions for Strand B (opposite side)
        const x2 = Math.cos(angle + Math.PI) * radius;
        const z2 = Math.sin(angle + Math.PI) * radius;

        // --- STRAND A (Sugar + Phosphate) ---
        // Sugar A
        const sugarA = new THREE.Mesh(sugarGeo, sugarMat);
        sugarA.position.set(x1, y, z1);
        dnaGroup.add(sugarA);

        // Phosphate A (Offset slightly from sugar)
        const p1x = Math.cos(angle + 0.3) * (radius + 1.5);
        const p1z = Math.sin(angle + 0.3) * (radius + 1.5);
        const phosA = new THREE.Mesh(sphereGeo, phosphateMat);
        phosA.position.set(p1x, y + 0.5, p1z);
        dnaGroup.add(phosA);

        // GREEN BOND: Sugar -> Phosphate
        const bondGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5);
        const bondA = new THREE.Mesh(bondGeo, bondMat);
        // Align bond between sugar and phosphate
        bondA.position.copy(sugarA.position).lerp(phosA.position, 0.5);
        bondA.lookAt(phosA.position);
        bondA.rotateX(Math.PI / 2); 
        dnaGroup.add(bondA);

        // --- STRAND B (Sugar + Phosphate) ---
        // Sugar B
        const sugarB = new THREE.Mesh(sugarGeo, sugarMat);
        sugarB.position.set(x2, y, z2);
        dnaGroup.add(sugarB);

        // Phosphate B
        const p2x = Math.cos(angle + Math.PI + 0.3) * (radius + 1.5);
        const p2z = Math.sin(angle + Math.PI + 0.3) * (radius + 1.5);
        const phosB = new THREE.Mesh(sphereGeo, phosphateMat);
        phosB.position.set(p2x, y + 0.5, p2z);
        dnaGroup.add(phosB);

        // GREEN BOND: Sugar -> Phosphate
        const bondB = new THREE.Mesh(bondGeo, bondMat);
        bondB.position.copy(sugarB.position).lerp(phosB.position, 0.5);
        bondB.lookAt(phosB.position);
        bondB.rotateX(Math.PI / 2);
        dnaGroup.add(bondB);

        // --- BASES (Rungs of the ladder) ---
        // We alternate which side gets the 2-ring vs 1-ring base
        const isPurineSideA = i % 2 === 0;

        // Base A (Attached to Sugar A)
        // 2 rings = Longer cylinder, 1 ring = Shorter cylinder
        const lenA = isPurineSideA ? 3.5 : 2.0; 
        const matA = isPurineSideA ? basePurineMat : basePyrimMat;
        
        const baseAGeo = new THREE.BoxGeometry(lenA, 0.4, 0.4);
        const baseA = new THREE.Mesh(baseAGeo, matA);
        
        // Position base halfway towards center
        const center = new THREE.Vector3(0, y, 0);
        baseA.position.copy(sugarA.position).lerp(center, 0.3);
        baseA.lookAt(center);
        dnaGroup.add(baseA);

        // Base B (Attached to Sugar B)
        const lenB = isPurineSideA ? 2.0 : 3.5; // Complementary
        const matB = isPurineSideA ? basePyrimMat : basePurineMat;
        
        const baseBGeo = new THREE.BoxGeometry(lenB, 0.4, 0.4);
        const baseB = new THREE.Mesh(baseBGeo, matB);
        baseB.position.copy(sugarB.position).lerp(center, 0.3);
        baseB.lookAt(center);
        dnaGroup.add(baseB);
        
        // Hydrogen Bond (White line in center)
        const hBondGeo = new THREE.CylinderGeometry(0.05, 0.05, 1);
        const hBond = new THREE.Mesh(hBondGeo, connectorMat);
        hBond.position.set(0, y, 0);
        hBond.lookAt(sugarA.position);
        hBond.rotateZ(Math.PI / 2);
        dnaGroup.add(hBond);
    }

    // --- ANIMATION CONTROLS ---
    let isPlaying = true;
    let rotationSpeed = 0.02;

    const toggleBtn = document.getElementById('toggleBtn');
    const speedRange = document.getElementById('speedRange');

    toggleBtn.addEventListener('click', () => {
        isPlaying = !isPlaying;
        toggleBtn.innerText = isPlaying ? "PAUSE" : "PLAY";
        toggleBtn.style.background = isPlaying ? "#00d2ff" : "#ff4444";
    });

    speedRange.addEventListener('input', (e) => {
        rotationSpeed = parseFloat(e.target.value);
    });

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying) {
            dnaGroup.rotation.y += rotationSpeed;
        }

        renderer.render(scene, camera);
    }
    animate();

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
